     1                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
     2                                  ;Author information
     3                                  ;  Author name: Floyd Holliday
     4                                  ;  Author email: holliday@fullerton.edu or activeprofessor@yahoo.com
     5                                  ;  Author location: Fullerton, California
     6                                  ;Course information
     7                                  ;  Course number: CPSC240
     8                                  ;  Assignment number: 8
     9                                  ;  Due date: 2014-Aug-25
    10                                  ;Project information
    11                                  ;  Project title: CPU Identification
    12                                  ;  Purpose: Extract information about the microprocessor in this computer.
    13                                  ;  Status: No known errors
    14                                  ;  Project files: cpuidentification.c, cpuidentify.asm
    15                                  ;  Background: Intel programmers created a 32-bit version of the CPU Identification suite.  This program is a new rewrite of that early
    16                                  ;  software to run on 64-bit platforms.
    17                                  ;  Project references: Intel Processor Identification and the CPUID Instruction, Application Note 485, revised May 2012 (App-Note 485).
    18                                  ;Module information
    19                                  ;  This module's call name: processoridentification
    20                                  ;  Language: X86-64
    21                                  ;  Syntax: Intel
    22                                  ;  History: 2013-07-07 Begin development
    23                                  ;           2014-06-12 Header comments expanded
    24                                  ;           2014-12-18 Bitmap extraction added
    25                                  ;           2019-12-29 CPU frequency added
    26                                  ;  Purpose: This program will identify many properties of the processor in this computer.
    27                                  ;  File name: cpuidentify.asm
    28                                  ;  Status: In production.  No known errors.
    29                                  ;  Future enhancements: Add backup of state components by use of xsave.
    30                                  ;Translator information
    31                                  ;  Linux: nasm -f elf64 -l cpuidentify.lis -o cpuidentify.o cpuidentify.asm
    32                                  ;References and credits
    33                                  ;  Intel Processor Identification and the CPUID Instruction, Application Note 485, revised May 2012 (App-Note 485).
    34                                  ;Format information
    35                                  ;  Page width: 172 columns
    36                                  ;  Begin comments: 61
    37                                  ;  Optimal print specification: Landscape, 7 points, monospace, 8Â½x11 paper
    38                                  ;Permissions
    39                                  ;  The source code is free for use by members of the 240 programming course.  You should credit this source if you borrow executable statements from this program.  The
    40                                  ;  instructions are free to use, but the borrower must create his or her own comments.  The comments belong to the author.
    41                                  
    42                                  ;===== Begin area for source code ==========================================================================================================================================
    43                                  ;%include "debug.inc"                                       ;This statement makes the debugger available to this program.  However, the debugger is not currently in use.
    44                                                                                              ;Therefore, the statement is commented out.  The include is an example of an assembler directive.  Here the
    45                                                                                              ;assembler will insert the source code of the debugger.
    46                                  
    47                                  extern printf                                               ;This function will be linked into the executable by the linker
    48                                  
    49                                  global processoridentification                              ;Make this program callable by modules outside this file
    50                                  
    51                                  segment .data                                               ;Place initialized data in this segment
    52                                  
    53 00000000 57656C636F6D652074-     welcome db "Welcome to CPUID verification", 10, 0
    53 00000009 6F2043505549442076-
    53 00000012 657269666963617469-
    53 0000001B 6F6E0A00           
    54 0000001F 257300                  specifierforstringdata db "%s", 0
    55 00000022 0A00                    newline db 10, 0
    56                                  
    57 00000024 546869732070726F67-     purpose db "This program will first determine if the cpuid instruction is implemented in the present processor", 10, 0
    57 0000002D 72616D2077696C6C20-
    57 00000036 666972737420646574-
    57 0000003F 65726D696E65206966-
    57 00000048 207468652063707569-
    57 00000051 6420696E7374727563-
    57 0000005A 74696F6E2069732069-
    57 00000063 6D706C656D656E7465-
    57 0000006C 6420696E2074686520-
    57 00000075 70726573656E742070-
    57 0000007E 726F636573736F720A-
    57 00000087 00                 
    58                                  
    59 00000088 54686520696E697469-     initialrflags db "The initial value of rflags is %016lx", 10, 0
    59 00000091 616C2076616C756520-
    59 0000009A 6F662072666C616773-
    59 000000A3 20697320253031366C-
    59 000000AC 780A00             
    60 000000AF 42697420233231206F-     bit21 db "Bit #21 of rflags is  %01ld", 10, 0
    60 000000B8 662072666C61677320-
    60 000000C1 697320202530316C64-
    60 000000CA 0A00               
    61 000000CC 4E6F77207468652076-     modifiedrflags db "Now the value of rflags is %016lx", 10, 0
    61 000000D5 616C7565206F662072-
    61 000000DE 666C61677320697320-
    61 000000E7 253031366C780A00   
    62                                  
    63 000000EF 426974202332312068-     cpuidmessage db "Bit #21 has been successfully changed, and therefore the cpuid instruction is implemented on this machine.", 10, 10, 0
    63 000000F8 6173206265656E2073-
    63 00000101 75636365737366756C-
    63 0000010A 6C79206368616E6765-
    63 00000113 642C20616E64207468-
    63 0000011C 657265666F72652074-
    63 00000125 686520637075696420-
    63 0000012E 696E73747275637469-
    63 00000137 6F6E20697320696D70-
    63 00000140 6C656D656E74656420-
    63 00000149 6F6E2074686973206D-
    63 00000152 616368696E652E0A0A-
    63 0000015B 00                 
    64 0000015C 53696E636520626974-     noncpuidmessage db "Since bit #21 remains unchanged the conclusion is that cpuid is not implemented in this processor.", 10, 0
    64 00000165 202332312072656D61-
    64 0000016E 696E7320756E636861-
    64 00000177 6E6765642074686520-
    64 00000180 636F6E636C7573696F-
    64 00000189 6E2069732074686174-
    64 00000192 206370756964206973-
    64 0000019B 206E6F7420696D706C-
    64 000001A4 656D656E7465642069-
    64 000001AD 6E2074686973207072-
    64 000001B6 6F636573736F722E0A-
    64 000001BF 00                 
    65                                  
    66 000001C0 546865207374617465-     statecomponentmessage db "The state component bit map of this processor is %1ld.", 10, 0
    66 000001C9 20636F6D706F6E656E-
    66 000001D2 7420626974206D6170-
    66 000001DB 206F66207468697320-
    66 000001E4 70726F636573736F72-
    66 000001ED 2069732025316C642E-
    66 000001F6 0A00               
    67 000001F8 41206269746D617020-     statecomponentexplanation db "A bitmap value from 4 through 7 indicates the AVX component (also known as 'State Component #2') is present.", 10,
    67 00000201 76616C75652066726F-
    67 0000020A 6D2034207468726F75-
    67 00000213 6768203720696E6469-
    67 0000021C 636174657320746865-
    67 00000225 2041565820636F6D70-
    67 0000022E 6F6E656E742028616C-
    67 00000237 736F206B6E6F776E20-
    67 00000240 617320275374617465-
    67 00000249 20436F6D706F6E656E-
    67 00000252 742023322729206973-
    67 0000025B 2070726573656E742E-
    67 00000264 0A                 
    68 00000265 412076616C7565206C-                               db "A value less than 4 indicates the AVX component is absent.", 10, 10, 0
    68 0000026E 657373207468616E20-
    68 00000277 3420696E6469636174-
    68 00000280 657320746865204156-
    68 00000289 5820636F6D706F6E65-
    68 00000292 6E7420697320616273-
    68 0000029B 656E742E0A0A00     
    69                                  
    70 000002A2 546865206C61726765-     largestbasicdescription db "The largest basic function number implemented on this machine is %ld.", 10, 0
    70 000002AB 737420626173696320-
    70 000002B4 66756E6374696F6E20-
    70 000002BD 6E756D62657220696D-
    70 000002C6 706C656D656E746564-
    70 000002CF 206F6E207468697320-
    70 000002D8 6D616368696E652069-
    70 000002E1 7320256C642E0A00   
    71 000002E9 5468657265666F7265-     largestbasicconclusion db "Therefore, when extracting basic information, the input value must be in the range: "
    71 000002F2 2C207768656E206578-
    71 000002FB 7472616374696E6720-
    71 00000304 626173696320696E66-
    71 0000030D 6F726D6174696F6E2C-
    71 00000316 2074686520696E7075-
    71 0000031F 742076616C7565206D-
    71 00000328 75737420626520696E-
    71 00000331 207468652072616E67-
    71 0000033A 653A20             
    72 0000033D 3020E289A420696E70-                            db "0 â¤ input value â¤ %ld.", 10, 10, 0
    72 00000346 75742076616C756520-
    72 0000034F E289A420256C642E0A-
    72 00000358 0A00               
    73                                  
    74 0000035A 546865206C61726765-     largestextendeddescription db "The largest extended function number implemented on this machine is 0x%08x = %ld.", 10, 0
    74 00000363 737420657874656E64-
    74 0000036C 65642066756E637469-
    74 00000375 6F6E206E756D626572-
    74 0000037E 20696D706C656D656E-
    74 00000387 746564206F6E207468-
    74 00000390 6973206D616368696E-
    74 00000399 652069732030782530-
    74 000003A2 3878203D20256C642E-
    74 000003AB 0A00               
    75 000003AD 5468657265666F7265-     largestextendedconclusion db "Therefore, when extracting extended information, the input value must be in the range: "
    75 000003B6 2C207768656E206578-
    75 000003BF 7472616374696E6720-
    75 000003C8 657874656E64656420-
    75 000003D1 696E666F726D617469-
    75 000003DA 6F6E2C207468652069-
    75 000003E3 6E7075742076616C75-
    75 000003EC 65206D757374206265-
    75 000003F5 20696E207468652072-
    75 000003FE 616E67653A20       
    76 00000404 307838303030303030-                               db "0x80000000 â¤ input value â¤ 0x%08x.", 10, 10, 0
    76 0000040D 3020E289A420696E70-
    76 00000416 75742076616C756520-
    76 0000041F E289A4203078253038-
    76 00000428 782E0A0A00         
    77                                  
    78 0000042D 5468652056656E646F-     vendoridstring db "The Vendor ID of the CPU in this computer is %s", 0
    78 00000436 72204944206F662074-
    78 0000043F 68652043505520696E-
    78 00000448 207468697320636F6D-
    78 00000451 707574657220697320-
    78 0000045A 257300             
    79                                  
    80 0000045D 457874656E64656420-     extendedfamilynumber db "Extended family number: %ld", 10, 0
    80 00000466 66616D696C79206E75-
    80 0000046F 6D6265723A20256C64-
    80 00000478 0A00               
    81 0000047A 457874656E64656420-     extendedmodelnumber db "Extended model number: %ld", 10, 0
    81 00000483 6D6F64656C206E756D-
    81 0000048C 6265723A20256C640A-
    81 00000495 00                 
    82 00000496 50726F636573736F72-     processortypenumber db "Processor type number: %ld", 10, 0
    82 0000049F 2074797065206E756D-
    82 000004A8 6265723A20256C640A-
    82 000004B1 00                 
    83 000004B2 50726F636573736F72-     processorfamilynumber db "Processor family number: %ld", 10, 0
    83 000004BB 2066616D696C79206E-
    83 000004C4 756D6265723A20256C-
    83 000004CD 640A00             
    84 000004D0 50726F636573736F72-     processormodelnumber db "Processor model number: %ld", 10, 0
    84 000004D9 206D6F64656C206E75-
    84 000004E2 6D6265723A20256C64-
    84 000004EB 0A00               
    85 000004ED 50726F636573736F72-     processorsteppingidnumber db "Processor stepping ID number: %ld",
    85 000004F6 207374657070696E67-
    85 000004FF 204944206E756D6265-
    85 00000508 723A20256C64       
    86 0000050E 2C2077686963682069-                               db ", which is also known as the processor revision number.", 10, 0
    86 00000517 7320616C736F206B6E-
    86 00000520 6F776E206173207468-
    86 00000529 652070726F63657373-
    86 00000532 6F7220726576697369-
    86 0000053B 6F6E206E756D626572-
    86 00000544 2E0A00             
    87                                  
    88 00000547 5468652050726F6365-     initialprocessorbrandstring db "The Processor Brand of this cpu is ", 0
    88 00000550 73736F72204272616E-
    88 00000559 64206F662074686973-
    88 00000562 206370752069732000 
    89 0000056B 5468652070726F6365-     brandstringunsupported db "The processor Brand String is not supported in this cpu.", 10, 0
    89 00000574 73736F72204272616E-
    89 0000057D 6420537472696E6720-
    89 00000586 6973206E6F74207375-
    89 0000058F 70706F727465642069-
    89 00000598 6E2074686973206370-
    89 000005A1 752E0A00           
    90                                  
    91 000005A5 546865206272616E64-     brandidformat db "The brand id number of the CPU in this computer is %ld.", 10, 0
    91 000005AE 206964206E756D6265-
    91 000005B7 72206F662074686520-
    91 000005C0 43505520696E207468-
    91 000005C9 697320636F6D707574-
    91 000005D2 657220697320256C64-
    91 000005DB 2E0A00             
    92 000005DE 5468652070726F6365-     processorsignatureformat db "The processor signature of the CPU in this computer is %lx", 10
    92 000005E7 73736F72207369676E-
    92 000005F0 6174757265206F6620-
    92 000005F9 746865204350552069-
    92 00000602 6E207468697320636F-
    92 0000060B 6D7075746572206973-
    92 00000614 20256C780A         
    93 00000619 5468652070726F6365-                              db "The processor signature has the following components:", 10, 0
    93 00000622 73736F72207369676E-
    93 0000062B 617475726520686173-
    93 00000634 2074686520666F6C6C-
    93 0000063D 6F77696E6720636F6D-
    93 00000646 706F6E656E74733A0A-
    93 0000064F 00                 
    94                                  
    95 00000650 546865206272616E64-     brandidnumber db "The brand id number of the CPU in this computer is %ld.", 10, 0
    95 00000659 206964206E756D6265-
    95 00000662 72206F662074686520-
    95 0000066B 43505520696E207468-
    95 00000674 697320636F6D707574-
    95 0000067D 657220697320256C64-
    95 00000686 2E0A00             
    96                                  
    97 00000689 546865204C32206361-     cacheformat db "The L2 cache in this computer has size %ld kiB.", 10, 0
    97 00000692 63686520696E207468-
    97 0000069B 697320636F6D707574-
    97 000006A4 657220686173207369-
    97 000006AD 7A6520256C64206B69-
    97 000006B6 422E0A00           
    98                                  
    99                                  
   100 000006BA 45787472616374696F-     noserialnumbermessage db "Extraction of the serial number is not implemented in this cpu.", 10 ,0
   100 000006C3 6E206F662074686520-
   100 000006CC 73657269616C206E75-
   100 000006D5 6D626572206973206E-
   100 000006DE 6F7420696D706C656D-
   100 000006E7 656E74656420696E20-
   100 000006F0 74686973206370752E-
   100 000006F9 0A00               
   101 000006FB 546865207365726961-     serialnumberinitial db "The serial number of the CPU is %08ld", 0
   101 00000704 6C206E756D62657220-
   101 0000070D 6F6620746865204350-
   101 00000716 55206973202530386C-
   101 0000071F 6400               
   102 00000721 2530386C6400            serialnumbermiddle db "%08ld", 0
   103 00000727 2530386C640A00          serialnumberlast db "%08ld", 10, 0
   104                                  
   105 0000072E 546865206D696E696D-     cpufrequency db "The minimum cpu frequency of all cores in this processor is %ldMHz and the maximum frequency is %ldMHz.",10,0
   105 00000737 756D20637075206672-
   105 00000740 657175656E6379206F-
   105 00000749 6620616C6C20636F72-
   105 00000752 657320696E20746869-
   105 0000075B 732070726F63657373-
   105 00000764 6F7220697320256C64-
   105 0000076D 4D487A20616E642074-
   105 00000776 6865206D6178696D75-
   105 0000077F 6D206672657175656E-
   105 00000788 637920697320256C64-
   105 00000791 4D487A2E0A00       
   106 00000797 45787472616374696F-     cpufrequencynotsupported db "Extraction of minimum and maximum cpu frequencies is not supported by this processor.",10,0
   106 000007A0 6E206F66206D696E69-
   106 000007A9 6D756D20616E64206D-
   106 000007B2 6178696D756D206370-
   106 000007BB 75206672657175656E-
   106 000007C4 63696573206973206E-
   106 000007CD 6F7420737570706F72-
   106 000007D6 746564206279207468-
   106 000007DF 69732070726F636573-
   106 000007E8 736F722E0A00       
   107                                  
   108 000007EE 257300                  stringformat db "%s", 0
   109 000007F1 25732E0A00              stringformatwithnewline db "%s.", 10, 0
   110                                  
   111 000007F6 546865207873617665-     xsavenotsupported.notsupportedmessage db "The xsave instruction is not supported in this microprocessor.", 10
   111 000007FF 20696E737472756374-
   111 00000808 696F6E206973206E6F-
   111 00000811 7420737570706F7274-
   111 0000081A 656420696E20746869-
   111 00000823 73206D6963726F7072-
   111 0000082C 6F636573736F722E0A 
   112 00000835 486F77657665722C20-                                           db "However, processing will continue without backing up state component data", 10, 0
   112 0000083E 70726F63657373696E-
   112 00000847 672077696C6C20636F-
   112 00000850 6E74696E7565207769-
   112 00000859 74686F757420626163-
   112 00000862 6B696E672075702073-
   112 0000086B 7461746520636F6D70-
   112 00000874 6F6E656E7420646174-
   112 0000087D 610A00             
   113                                  
   114 00000880 257300                  xsavenotsupported.stringformat db "%s", 0
   115                                  
   116                                  segment .bss                                                ;Place uninitialized data in this segment
   117                                  
   118                                  align 64                                                    ;Ask that the next data declaration start on a 64-byte boundary.
   119 00000000 <res 00000340>          backuparea resb 832                                         ;Create an array for backup storage having 832 bytes.
   120                                  
   121                                  segment .text                                               ;Place executable statements in this segment
   122                                  
   123                                  processoridentification:                                    ;Entry point: execution will begin here.
   124                                  
   125                                  ;=========== Back up all the GPR registers except rax, rsp, and rip =======================================================================================================
   126                                  
   127 00000000 55                      push       rbp                                              ;Save a copy of the stack base pointer
   128 00000001 4889E5                  mov        rbp, rsp                                         ;We do this in order to be 100% compatible with C and C++.
   129 00000004 53                      push       rbx                                              ;Back up rbx
   130 00000005 51                      push       rcx                                              ;Back up rcx
   131 00000006 52                      push       rdx                                              ;Back up rdx
   132 00000007 56                      push       rsi                                              ;Back up rsi
   133 00000008 57                      push       rdi                                              ;Back up rdi
   134 00000009 4150                    push       r8                                               ;Back up r8
   135 0000000B 4151                    push       r9                                               ;Back up r9
   136 0000000D 4152                    push       r10                                              ;Back up r10
   137 0000000F 4153                    push       r11                                              ;Back up r11
   138 00000011 4154                    push       r12                                              ;Back up r12
   139 00000013 4155                    push       r13                                              ;Back up r13
   140 00000015 4156                    push       r14                                              ;Back up r14
   141 00000017 4157                    push       r15                                              ;Back up r15
   142 00000019 9C                      pushf                                                       ;Back up rflags
   143                                  
   144                                  
   145                                  ;===========================================================================================================================================================================
   146                                  ;===== Begin State Component Backup ========================================================================================================================================
   147                                  ;==========================================================================================================================================================================
   148                                  
   149                                  ;=========== Before proceeding verify that this computer supports xsave and xrstor =========================================================================================
   150                                  ;Bit #26 of rcx, written rcx[26], must be 1; otherwise xsave and xrstor are not supported by this computer.
   151                                  ;Preconditions: rax holds 1.
   152 0000001A B801000000              mov        rax, 1
   153                                  
   154                                  ;Execute the cpuid instruction
   155 0000001F 0FA2                    cpuid
   156                                  
   157                                  ;Postconditions: If rcx[26]==1 then xsave is supported.  If rcx[26]==0 then xsave is not supported.
   158                                  
   159                                  ;=========== Extract bit #26 and test it ===================================================================================================================================
   160                                  
   161 00000021 4881E100000004          and        rcx, 0x0000000004000000                          ;The mask 0x0000000004000000 has a 1 in position #26.  Now rcx is either all zeros or
   162                                                                                              ;has a single 1 in position #26 and zeros everywhere else.
   163 00000028 4883F900                cmp        rcx, 0                                           ;Is (rcx == 0)?
   164 0000002C 742A                    je         xsavenotsupported                                ;Skip the section that backs up state component data.
   165                                  
   166                                  ;========== Call the function to obtain the bitmap of state components ====================================================================================================
   167                                  
   168                                  ;Preconditions
   169 0000002E B80D000000              mov        rax, 0x000000000000000d                          ;Place 13 in rax.  This number is provided in the Intel manual
   170 00000033 B900000000              mov        rcx, 0                                           ;0 is parameter for subfunction 0
   171                                  
   172                                  ;Call the function
   173 00000038 0FA2                    cpuid                                                       ;cpuid is an essential function that returns information about the cpu
   174                                  
   175                                  ;Postconditions (There are 2 of these):
   176                                  
   177                                  ;1.  edx:eax is a bit map of state components managed by xsave.  At the time this program was written (2014 June) there were exactly 3 state components.  Therefore, bits
   178                                  ;    numbered 2, 1, and 0 are important for current cpu technology.
   179                                  ;2.  ecx holds the number of bytes required to store all the data of enabled state components. [Post condition 2 is not used in this program.]
   180                                  ;This program assumes that under current technology (year 2014) there are at most three state components having a maximum combined data storage requirement of 832 bytes.
   181                                  ;Therefore, the value in ecx will be less than or equal to 832.
   182                                  
   183                                  ;Precaution: As an insurance against a future time when there will be more than 3 state components in a processor of the X86 family the state component bitmap is masked to
   184                                  ;allow only 3 state components maximum.
   185                                  
   186 0000003A 41BF07000000            mov        r15, 7                                           ;7 equals three 1 bits.
   187 00000040 4C21F8                  and        rax, r15                                         ;Bits 63-3 become zeros.
   188 00000043 41BF00000000            mov        r15, 0                                           ;0 equals 64 binary zeros.
   189 00000049 4C21FA                  and        rdx, r15                                         ;Zero out rdx.
   190                                  
   191                                  ;========== Save all the data of all three components except GPRs =========================================================================================================
   192                                  
   193                                  ;The instruction xsave will save those state components with on bits in the bitmap.  At this point edx:eax continues to hold the state component bitmap.
   194                                  
   195                                  ;Precondition: edx:eax holds the state component bit map.  This condition has been met by the two pops preceding this statement.
   196 0000004C 0FAE2425[00000000]      xsave      [backuparea]                                     ;All the data of state components managed by xsave have been written to backuparea.
   197                                  
   198 00000054 6AFF                    push qword -1                                               ;Set a flag (-1 = true) to indicate that state component data were backed up.
   199 00000056 EB20                    jmp        startapplication
   200                                  
   201                                  ;========== Show message xsave is not supported on this platform ==========================================================================================================
   202                                  xsavenotsupported:
   203                                  
   204 00000058 B800000000              mov        rax, 0
   205 0000005D 48BF-                   mov        rdi, .stringformat
   205 0000005F [8008000000000000] 
   206 00000067 48BE-                   mov        rsi, .notsupportedmessage                        ;"The xsave instruction is not supported in this microprocessor.
   206 00000069 [F607000000000000] 
   207 00000071 E8(00000000)            call       printf
   208                                  
   209 00000076 6A00                    push qword 0                                                ;Set a flag (0 = false) to indicate that state component data were not backed up.
   210                                  
   211                                  ;==========================================================================================================================================================================
   212                                  ;===== End of State Component Backup ======================================================================================================================================
   213                                  ;==========================================================================================================================================================================
   214                                  
   215                                  
   216                                  ;==========================================================================================================================================================================
   217                                  startapplication: ;===== Begin the application here: Identify the CPU =====================================================================================================
   218                                  ;==========================================================================================================================================================================
   219                                  
   220                                  ;===== Show the welcome message followed by the purpose message ===========================================================================================================
   221                                  
   222 00000078 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   223 0000007D 48BF-                   mov       rdi, specifierforstringdata                       ;"%s"
   223 0000007F [1F00000000000000] 
   224 00000087 48BE-                   mov       rsi, welcome                                      ;"Welcome to CPUID verification"
   224 00000089 [0000000000000000] 
   225 00000091 E8(00000000)            call      printf                                            ;Use external function to handle the output
   226                                  
   227 00000096 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   228 0000009B 48BF-                   mov       rdi, specifierforstringdata                       ;"%s"
   228 0000009D [1F00000000000000] 
   229 000000A5 48BE-                   mov       rsi, purpose                                      ;"This program will determine if the cpuid instruction is correctly ..."
   229 000000A7 [2400000000000000] 
   230 000000AF E8(00000000)            call      printf                                            ;Use external function to handle the output
   231                                  
   232                                  ;===== Show the initial value of rflags ===================================================================================================================================
   233                                  
   234 000000B4 4C8B7C2408              mov       r15, [rsp+8]                                      ;Place a working copy of rflags in the state when this module began execution.  rflags is subject to change by
   235                                                                                              ;later instructions, and therefore, the original value of rflags is copied to r15.
   236 000000B9 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   237 000000BE 48BF-                   mov       rdi, initialrflags                                ;"%016lx"
   237 000000C0 [8800000000000000] 
   238 000000C8 4C89FE                  mov       rsi, r15                                          ;Original value from rflags will be printed
   239 000000CB E8(00000000)            call      printf                                            ;Use external function to handle the output
   240                                  
   241                                  ;===== Isolate bit #21 ====================================================================================================================================================
   242 000000D0 4157                    push      r15                                               ;Save a copy of the original rflags
   243 000000D2 4D89FE                  mov       r14, r15                                          ;r14 holds the original data from rflags
   244 000000D5 49C1EE15                shr       r14, 21                                           ;Eliminate 21 bits on the right of bit #21, which is now in position 0
   245 000000D9 4983E601                and       r14, 1                                            ;Set all bits #79 thru 1 to zero.  Bit #0 remains unchanged.
   246                                  
   247                                  ;===== Show bit #21 =======================================================================================================================================================
   248                                  
   249 000000DD B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   250 000000E2 48BF-                   mov       rdi, bit21                                        ;"%01ld"
   250 000000E4 [AF00000000000000] 
   251 000000EC 4C89F6                  mov       rsi, r14                                          ;Bit #21 (now in position #0) is passed to the printf function
   252 000000EF E8(00000000)            call      printf                                            ;Use external function to handle the output
   253                                  
   254                                  ;===== Replace bit #21 with its logical complement ========================================================================================================================
   255                                  
   256 000000F4 4981F700002000          xor       r15, 0x0000000000200000                           ;By properties of xor bit #21 has been complemented; other bits remain unchanged.
   257 000000FB 4157                    push      r15                                               ;Push the new data for rflags on the stack in order to copy that data to rflags
   258 000000FD 9D                      popf                                                        ;Now rflags has the same data as before except bit #23 has flipped
   259                                  
   260                                  ;===== Show the data in rflags to verify visually any changes in bit #21 ==================================================================================================
   261                                  
   262 000000FE 9C                      pushf                                                       ;Copy the current data of rflags to the stack
   263 000000FF 415F                    pop       r15                                               ;Copy the current data of rflags to r15
   264 00000101 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   265 00000106 48BF-                   mov       rdi, modifiedrflags                               ;"%016lx"
   265 00000108 [CC00000000000000] 
   266 00000110 4C89FE                  mov       rsi, r15                                          ;Data from the current value of rflags will be outputted
   267 00000113 E8(00000000)            call      printf                                            ;Use external function to handle the output
   268                                  
   269                                  ;===== Output the conclusion ===============================================================================================================================================
   270                                  ;r15 holds the modified data of rflags
   271 00000118 415E                    pop       r14                                               ;r14 holds the original data of rflags
   272 0000011A 4D39FE                  cmp       r14, r15                                          ;Compare the original rflags with the modified rflags
   273 0000011D 7420                    je        notimplemented                                    ;if r14==r15 execute at entry notimplemented
   274                                  
   275                                  ;if r14 /= r15 then continue directly below; no jump instruction is needed.
   276                                  
   277                                  ;===== Show message cpuid is implemented ==================================================================================================================================
   278                                  
   279 0000011F B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers       
   280 00000124 48BF-                   mov       rdi, specifierforstringdata                       ;"%s"
   280 00000126 [1F00000000000000] 
   281 0000012E 48BE-                   mov       rsi, cpuidmessage                                 ;"Bit #21 has been successfully changed, .... "
   281 00000130 [EF00000000000000] 
   282 00000138 E8(00000000)            call      printf                                            ;Use external function to handle the output
   283                                  
   284 0000013D EB23                    jmp       showbitmap                                        ;Execute at entry showbitmap
   285                                  
   286                                  ;===== Show message cpuid is not implemented ==============================================================================================================================
   287                                  notimplemented:                                             ;An entry point for a jump instruction
   288                                  
   289 0000013F B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   290 00000144 48BF-                   mov       rdi, specifierforstringdata                       ;"%s"
   290 00000146 [1F00000000000000] 
   291 0000014E 48BE-                   mov       rsi, noncpuidmessage                              ;The cpuid instruction is not implemented
   291 00000150 [5C01000000000000] 
   292 00000158 E8(00000000)            call      printf                                            ;Use external function to handle the output
   293                                  
   294 0000015D E9BE040000              jmp       preparetoexit
   295                                  
   296                                  showbitmap: ;===== Extract and display the bitmap for this processor ======================================================================================================
   297                                  ;Preconditions before calling cpuid
   298 00000162 B80D000000              mov        rax, 0x000000000000000d                          ;13 is an input value required for extracting the bitmap
   299 00000167 B900000000              mov        rcx, 0                                           ;0 selects subfunction number 0 of cpuid
   300 0000016C 0FA2                    cpuid
   301                                  ;Postconditions after calling cpuid: the bitmap is in edx:eax.  We discard edx because all the relevant data are in eax.
   302 0000016E 41BFFFFFFFFF            mov        r15, 0x00000000ffffffff                          ;r15 is used for temporary storage for the next instruction.
   303 00000174 4C21F8                  and        rax, r15                                         ;Insure that the upper half of rax is entirely zero.
   304                                  ;rax holds the bitmap
   305                                  
   306                                  ;Display the bitmap, which is simply a positive integer.
   307 00000177 48BF-                   mov        rdi, statecomponentmessage                       ;"The state component bit map of this processor is %1ld"
   307 00000179 [C001000000000000] 
   308 00000181 4889C6                  mov        rsi, rax                                         ;The bitmap is in the second standard parameter for passing to printf
   309 00000184 B800000000              mov        rax, 0                                           ;This informs printf that no data from SSE or AVX will be outputted.
   310 00000189 E8(00000000)            call       printf                                           ;Use a function from the C-library to format the output.
   311                                  
   312                                  ;Display an explanation about the bitmap.
   313 0000018E 48BF-                   mov        rdi, stringformat                                ;"%s"
   313 00000190 [EE07000000000000] 
   314 00000198 48BE-                   mov        rsi, statecomponentexplanation                   ;"A bitmap value from 4 through 7 indicates the AVX component (also known as 'State Component #2') is present."
   314 0000019A [F801000000000000] 
   315 000001A2 B800000000              mov        rax, 0                                           ;This informs printf that no data from SSE or AVX will be outputted.
   316 000001A7 E8(00000000)            call       printf                                           ;Use a function from the C-library to format the output.
   317                                  
   318                                  ;===== Find the largest input number allowed for basic information by cpuid ================================================================================================
   319                                  
   320 000001AC B800000000              mov qword rax, 0                                            ;Zero is the input to the cpuid function
   321 000001B1 0FA2                    cpuid                                                       ;Call the function and the return value will be in rax
   322 000001B3 4989C7                  mov       r15, rax                                          ;Store the largest basic function number in r15 for safekeeping.
   323                                  
   324                                  ;===== Show the largest basic function number used by cpuid ================================================================================================================
   325                                  
   326 000001B6 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   327 000001BB 48BF-                   mov       rdi, largestbasicdescription                      ;"Largest basic function number ..."
   327 000001BD [A202000000000000] 
   328 000001C5 4C89FE                  mov       rsi, r15                                          ;Place the largest basic function number in the 2nd passing parameter
   329 000001C8 E8(00000000)            call      printf                                            ;Use external function to handle the output
   330                                  
   331                                  ;===== Display the conclusion regarding input values for extracting basic information =====================================================================================
   332                                  
   333 000001CD B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   334 000001D2 48BF-                   mov       rdi, largestbasicconclusion                       ;"Therefore, when extracting basic information the input value must be ... "
   334 000001D4 [E902000000000000] 
   335 000001DC 4C89FE                  mov       rsi, r15                                          ;Place the largest basic function number in the 2nd passing parameter
   336 000001DF E8(00000000)            call      printf                                            ;Use external function to handle the output
   337                                  
   338                                  ;===== Show the largest extended function number used by cpuid ============================================================================================================
   339                                  
   340 000001E4 B800000080              mov       rax, 0x0000000080000000                           ;Ref: Section 5.2 of App-Note 485.
   341 000001E9 0FA2                    cpuid                                                       ;This instruction will extract the largest extended function number.
   342 000001EB 4989C7                  mov       r15, rax                                          ;Copy the largest extended input function number to a stable place.
   343                                  
   344                                  ;===== Show the largest extended function number used by cpuid ============================================================================================================
   345                                  
   346 000001EE B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   347 000001F3 48BF-                   mov       rdi, largestextendeddescription
   347 000001F5 [5A03000000000000] 
   348 000001FD 4C89FE                  mov       rsi, r15                                          ;Copy the largest extended input value to the second passing parameter
   349 00000200 4C89FA                  mov       rdx, r15                                          ;Copy the largest extended input value to the third passing parameter
   350 00000203 E8(00000000)            call      printf                                            ;Use external function to handle the output
   351                                  
   352                                  ;===== Display the conclusion regarding input values for extracting basic information =====================================================================================
   353                                  
   354 00000208 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   355 0000020D 48BF-                   mov       rdi, largestextendedconclusion                    ;"Therefore, when extracting extended information, the input value must be ..."
   355 0000020F [AD03000000000000] 
   356 00000217 4C89FE                  mov       rsi, r15                                          ;Place the largest extended input function number in the 2nd passing parameter
   357 0000021A E8(00000000)            call      printf                                            ;Use external function to handle the output
   358                                  
   359                                  ;===== Obtain and show the vendor ID string ===============================================================================================================================
   360                                  
   361 0000021F BB00000000              mov qword rbx, 0                                            ;Zero out this register before cpuid writes to it
   362 00000224 B900000000              mov qword rcx, 0                                            ;Zero out this register before cpuid writes to it
   363 00000229 BA00000000              mov qword rdx, 0                                            ;Zero out this register before cpuid writes to it
   364                                  
   365 0000022E B800000000              mov qword rax, 0                                            ;Zero is the input to the cpuid function
   366 00000233 0FA2                    cpuid                                                       ;Call the function and the return value will be in rax
   367                                  
   368 00000235 51                      push      rcx                                               ;Save the last 4 bytes of the Vendor ID
   369 00000236 52                      push      rdx                                               ;Save the middle 4 bytes of the Vendor ID
   370 00000237 53                      push      rbx                                               ;Save the first 4 bytes of the Vendor ID
   371                                  
   372                                  ;The vendor ID string is in registers rbx, rdx, rcx -- 4 bytes of string in each register using little Endian format
   373                                  ;However, the three registers were pushed onto the integer stack where they are now.  By the nature of a stack the
   374                                  ;little Endian format has been converted to Big Endian format.  All that remains to do is to output the three substrings in 
   375                                  ;succession, and the Vendor ID will be outputted.
   376                                  
   377                                  ;Visual representation of the stack:
   378                                  ;      top+16-->|    UPCl|
   379                                  ;      top+8 -->|    etnI|
   380                                  ;      top ---->|    laeR|
   381                                  ;               ----------
   382                                  ;Note that each substring is null terminated by 4 bytes of null character in the most significant half of each 8-byte string.
   383                                  
   384 00000238 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   385 0000023D 48BF-                   mov       rdi, vendoridstring                               ;"The Vendor ID of the CPU in this computer is %s"
   385 0000023F [2D04000000000000] 
   386 00000247 4889E6                  mov       rsi, rsp
   387 0000024A E8(00000000)            call      printf
   388 0000024F 5B                      pop       rbx                                               ;Now the top of stack points to the start of the second 4-byte string.
   389                                  
   390 00000250 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   391 00000255 48BF-                   mov       rdi, stringformat                                 ;"%s"
   391 00000257 [EE07000000000000] 
   392 0000025F 4889E6                  mov       rsi, rsp
   393 00000262 E8(00000000)            call      printf
   394 00000267 5A                      pop       rdx                                               ;Now the top of stack points to the start of the third 4-byte string.
   395                                  
   396 00000268 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   397 0000026D 48BF-                   mov       rdi, stringformatwithnewline                      ;"%s", 10, 0
   397 0000026F [F107000000000000] 
   398 00000277 4889E6                  mov       rsi, rsp
   399 0000027A E8(00000000)            call      printf
   400 0000027F 59                      pop       rcx                                               ;Now the top of stack has returned to its state before Vendor ID was extracted.
   401                                  
   402                                  ;===== Extract feature information about this cpu =========================================================================================================================
   403                                  ;Ref: App-Note 485, section 5.1.2
   404                                  
   405 00000280 B801000000              mov       rax, 1                                            ;One is the input to the cpuid function
   406 00000285 0FA2                    cpuid                                                       ;Call the function and the return value will be in rax, rbx, rcx, rdx
   407                                  
   408                                  ;Processor feature information has been returned in rax, rbx, rcx, and rdx.  However, this program uses only the information from rax.
   409 00000287 4989C7                  mov       r15, rax                                          ;Copy feature information to r15 for safekeeping.
   410                                  
   411                                  ;===== Extract and show the processor signature ===========================================================================================================================
   412                                  
   413 0000028A B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   414 0000028F 48BF-                   mov       rdi, processorsignatureformat                     ;"The processor signature of the CPU in this computer is %016lx ... "
   414 00000291 [DE05000000000000] 
   415 00000299 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   416 0000029C E8(00000000)            call      printf                                            ;Use external function to handle the output
   417                                  
   418                                  ;Output the extended family number
   419 000002A1 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   420 000002A6 48BF-                   mov       rdi, extendedfamilynumber                         ;"Extended family number: %ld"
   420 000002A8 [5D04000000000000] 
   421 000002B0 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   422 000002B3 4881E60000F807          and       rsi, 0x0000000007f80000                           ;Mask bits 27:20
   423 000002BA 48C1EE13                shr       rsi, 19                                           ;Move the feature number to least significant bits of rsi
   424 000002BE E8(00000000)            call      printf                                            ;Use external function to handle the output
   425                                  
   426                                  ;Output the extended model number
   427 000002C3 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   428 000002C8 48BF-                   mov       rdi, extendedmodelnumber                          ;"Extended model number: %ld"
   428 000002CA [7A04000000000000] 
   429 000002D2 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   430 000002D5 4881E600000700          and       rsi, 0x0000000000070000                           ;Mask bits 19:16
   431 000002DC 48C1EE10                shr       rsi, 16                                           ;Move the feature number to least significant bits of rsi
   432 000002E0 E8(00000000)            call      printf                                            ;Use external function to handle the output
   433                                  
   434                                  ;Output the processor type number
   435 000002E5 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   436 000002EA 48BF-                   mov       rdi, processortypenumber                          ;"Processor type number: %ld"
   436 000002EC [9604000000000000] 
   437 000002F4 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   438 000002F7 4881E600300000          and       rsi, 0x0000000000003000                           ;Mask bits 13:12
   439 000002FE 48C1EE0C                shr       rsi, 12                                           ;Move the feature number to least significant bits of rsi
   440 00000302 E8(00000000)            call      printf                                            ;Use external function to handle the output
   441                                  
   442                                  ;Output the processor family number
   443 00000307 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   444 0000030C 48BF-                   mov       rdi, processorfamilynumber                        ;"Processor family number: %ld"
   444 0000030E [B204000000000000] 
   445 00000316 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   446 00000319 4881E6000F0000          and       rsi, 0x0000000000000f00                           ;Mask bits 11:8
   447 00000320 48C1EE08                shr       rsi, 8                                            ;Move the feature number to least significant bits of rsi
   448 00000324 E8(00000000)            call      printf                                            ;Use external function to handle the output
   449                                  
   450                                  ;Output the model number
   451 00000329 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   452 0000032E 48BF-                   mov       rdi, processormodelnumber                         ;"Processor model number: %ld"
   452 00000330 [D004000000000000] 
   453 00000338 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   454 0000033B 4881E6F0000000          and       rsi, 0x00000000000000f0                           ;Mask bits 7:4
   455 00000342 48C1EE04                shr       rsi, 4                                            ;Move the feature number to least significant bits of rsi
   456 00000346 E8(00000000)            call      printf                                            ;Use external function to handle the output
   457                                  
   458                                  ;Output the processor stepping ID number, which is also known as the revision number
   459 0000034B B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   460 00000350 48BF-                   mov       rdi, processorsteppingidnumber                    ;"Processor stepping ID number: %ld also known as processor revision number"
   460 00000352 [ED04000000000000] 
   461 0000035A 4C89FE                  mov       rsi, r15                                          ;Place feature information in the 2nd passing parameter
   462 0000035D 4883E60F                and       rsi, 0x000000000000000f                           ;Mask bits 3:0
   463 00000361 E8(00000000)            call      printf                                            ;Use external function to handle the output
   464                                  
   465                                  ;===== Determine if Brand String is supported in this processor ===========================================================================================================
   466                                  
   467 00000366 B800000080              mov       rax, 0x0000000080000000                           ;Intel App-Note 485 provides this input number
   468 0000036B 0FA2                    cpuid                                                       ;Call the function and the return value will be in rax
   469 0000036D 4989C7                  mov       r15, rax                                          ;Copy the return value to r15 for safekeeping
   470 00000370 B904000080              mov       rcx, 0x0000000080000004                           ;Intel App-Note 485 provides this number for comparison
   471 00000375 4939CF                  cmp       r15, rcx                                          ;Is r15 â¥ rcx? Yes => supported; No => unsupported.
   472 00000378 7D23                    jge       brandstringsupported
   473                                  
   474                                  ;Show the following message if Brand String is not supported
   475 0000037A B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   476 0000037F 48BF-                   mov       rdi, stringformat                                 ;"%s"
   476 00000381 [EE07000000000000] 
   477 00000389 48BE-                   mov       rsi, brandstringunsupported                       ;"The processor Brand String is not supported in this cpu."
   477 0000038B [6B05000000000000] 
   478 00000393 E8(00000000)            call      printf                                            ;Use external function to handle the output
   479 00000398 E95F010000              jmp       L2cache
   480                                  
   481                                  ;===== Extract and show the Processor Brand string ========================================================================================================================
   482                                  brandstringsupported:
   483                                  ;Ref: App-Note 485 Section 7.2.  The maximum length of the Brand string is 48 bytes of ascii.  The brand string is logically subdivided into 3 groups of 16 bytes per group.
   484                                  
   485                                  ;Obtain and display the first group of 16 bytes of the Brand string
   486 0000039D B802000080              mov        rax, 0x0000000080000002                          ;Intel provides this input number
   487 000003A2 0FA2                    cpuid                                                       ;The function will place return values in rdx, rcx, rbx, rax.
   488                                  
   489 000003A4 52                      push      rdx                                               ;Save bytes #12-15 of the first 16 bytes of the Brand string
   490 000003A5 51                      push      rcx                                               ;Save bytes #8-11 of the first 16 bytes of the Brand string
   491 000003A6 53                      push      rbx                                               ;Save bytes #4-7 of the first 16 bytes of the Brand string
   492 000003A7 50                      push      rax                                               ;Save bytes #0-3 of the first 16 bytes of the Brand string
   493                                  
   494 000003A8 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   495 000003AD 48BF-                   mov       rdi, stringformat
   495 000003AF [EE07000000000000] 
   496 000003B7 48BE-                   mov       rsi, initialprocessorbrandstring                  ;"The Processor Brand of this cpu is "
   496 000003B9 [4705000000000000] 
   497 000003C1 E8(00000000)            call      printf                                            ;Use external function to handle the output
   498                                  
   499 000003C6 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   500 000003CB 48BF-                   mov       rdi, stringformat                                 ;"%s"
   500 000003CD [EE07000000000000] 
   501 000003D5 4889E6                  mov       rsi, rsp                                          ;rsi points to the first 4 bytes within the first group of 16 bytes in the Brand string.
   502 000003D8 E8(00000000)            call      printf                                            ;Use external function to handle the output
   503 000003DD 5B                      pop       rbx
   504                                  
   505 000003DE B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   506 000003E3 48BF-                   mov       rdi, stringformat                                 ;"%s"
   506 000003E5 [EE07000000000000] 
   507 000003ED 4889E6                  mov       rsi, rsp                                          ;rsi points to the second 4 bytes within the first group of 16 bytes in the Brand string.
   508 000003F0 E8(00000000)            call      printf                                            ;Use external function to handle the output
   509 000003F5 5B                      pop       rbx
   510                                  
   511 000003F6 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   512 000003FB 48BF-                   mov       rdi, stringformat                                 ;"%s"
   512 000003FD [EE07000000000000] 
   513 00000405 4889E6                  mov       rsi, rsp                                          ;rsi points to the third 4 bytes within the first group of 16 bytes in the Brand string.
   514 00000408 E8(00000000)            call      printf                                            ;Use external function to handle the output
   515 0000040D 59                      pop       rcx
   516                                  
   517 0000040E B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   518 00000413 48BF-                   mov       rdi, stringformat                                 ;"%s"
   518 00000415 [EE07000000000000] 
   519 0000041D 4889E6                  mov       rsi, rsp                                          ;rsi points to the fourth 4 bytes within the first group of 16 bytes in the Brand string.
   520 00000420 E8(00000000)            call      printf                                            ;Use external function to handle the output
   521 00000425 5A                      pop       rdx
   522                                  
   523                                  ;Obtain and display the second group of 16 bytes of the Brand string
   524 00000426 B803000080              mov       rax, 0x0000000080000003                           ;Intel provides this input number
   525 0000042B 0FA2                    cpuid                                                       ;The function will place return values in rdx, rcx, rbx, rax.
   526                                  
   527 0000042D 52                      push      rdx                                               ;Save bytes #12-15 of the second 16 bytes of the Brand string
   528 0000042E 51                      push      rcx                                               ;Save bytes #8-11 of the second 16 bytes of the Brand string
   529 0000042F 53                      push      rbx                                               ;Save bytes #4-7 of the second 16 bytes of the Brand string
   530 00000430 50                      push      rax                                               ;Save bytes #0-3 of the second 16 bytes of the Brand string
   531                                  
   532 00000431 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   533 00000436 48BF-                   mov       rdi, stringformat
   533 00000438 [EE07000000000000] 
   534 00000440 4889E6                  mov       rsi, rsp                                          ;rsi points to the first 4 bytes within the second group of 16 bytes in the Brand string
   535 00000443 E8(00000000)            call      printf                                            ;Use external function to handle the output
   536 00000448 58                      pop       rax
   537                                  
   538 00000449 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   539 0000044E 48BF-                   mov       rdi, stringformat                                 ;"%s"
   539 00000450 [EE07000000000000] 
   540 00000458 4889E6                  mov       rsi, rsp                                          ;rsi points to the second 4 bytes within the second group of 16 bytes in the Brand string.
   541 0000045B E8(00000000)            call      printf                                            ;Use external function to handle the output
   542 00000460 5B                      pop       rbx
   543                                  
   544 00000461 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   545 00000466 48BF-                   mov       rdi, stringformat                                 ;"%s"
   545 00000468 [EE07000000000000] 
   546 00000470 4889E6                  mov       rsi, rsp                                          ;rsi points to the third 4 bytes within the second group of 16 bytes in the Brand string.
   547 00000473 E8(00000000)            call      printf                                            ;Use external function to handle the output
   548 00000478 59                      pop       rcx
   549                                  
   550 00000479 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   551 0000047E 48BF-                   mov       rdi, stringformat                                 ;"%s"
   551 00000480 [EE07000000000000] 
   552 00000488 4889E6                  mov       rsi, rsp                                          ;rsi points to the fourth 4 bytes within the second group of 16 bytes in the Brand string.
   553 0000048B E8(00000000)            call      printf                                            ;Use external function to handle the output
   554 00000490 5A                      pop       rdx
   555                                  
   556                                  ;Obtain and display the third group of 16 bytes of the Brand string
   557 00000491 B804000080              mov       rax, 0x0000000080000004                           ;Intel provides this input number
   558 00000496 0FA2                    cpuid                                                       ;The function will place return values in rdx, rcx, rbx, rax.
   559                                  
   560 00000498 52                      push      rdx                                               ;Save bytes #12-15 of the third 16 bytes of the Brand string
   561 00000499 51                      push      rcx                                               ;Save bytes #8-11 of the third 16 bytes of the Brand string
   562 0000049A 53                      push      rbx                                               ;Save bytes #4-7 of the third 16 bytes of the Brand string
   563 0000049B 50                      push      rax                                               ;Save bytes #0-3 of the third 16 bytes of the Brand string
   564                                  
   565 0000049C B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   566 000004A1 48BF-                   mov       rdi, stringformat                                 ;"%s"
   566 000004A3 [EE07000000000000] 
   567 000004AB 4889E6                  mov       rsi, rsp                                          ;rsi points to the first 4 bytes within the third group of 16 bytes in the Brand string
   568 000004AE E8(00000000)            call      printf
   569 000004B3 58                      pop       rax
   570                                  
   571 000004B4 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   572 000004B9 48BF-                   mov       rdi, stringformat                                 ;"%s"
   572 000004BB [EE07000000000000] 
   573 000004C3 4889E6                  mov       rsi, rsp                                          ;rsi points to the second 4 bytes within the third group of 16 bytes in the Brand string
   574 000004C6 E8(00000000)            call      printf
   575 000004CB 5B                      pop       rbx
   576                                  
   577 000004CC B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   578 000004D1 48BF-                   mov       rdi, stringformat
   578 000004D3 [EE07000000000000] 
   579 000004DB 4889E6                  mov       rsi, rsp                                          ;rsi points to the third 4 bytes within the third group of 16 bytes in the Brand string
   580 000004DE E8(00000000)            call      printf
   581 000004E3 59                      pop       rcx
   582                                  
   583 000004E4 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   584 000004E9 48BF-                   mov       rdi, stringformatwithnewline
   584 000004EB [F107000000000000] 
   585 000004F3 4889E6                  mov       rsi, rsp                                          ;rsi points to the fourth 4 bytes within the third group of 16 bytes in the Brand string
   586 000004F6 E8(00000000)            call      printf
   587 000004FB 5A                      pop       rdx
   588                                  
   589                                  ;===== End of obtain and display the Brand string =========================================================================================================================
   590                                  
   591                                  ;===== Find the size of L2 cache in bytes =================================================================================================================================
   592                                  L2cache:
   593                                  
   594 000004FC B806000080              mov qword rax, 0x0000000080000006                           ;This input value is provided by Intel as input for finding size of cache
   595 00000501 B900000000              mov qword rcx, 0                                            ;Remove old data from rcx
   596 00000506 0FA2                    cpuid
   597                                  
   598                                  ;Postconditions: rcx[31:16] now holds the size in binary kilobytes (kiB) of L2 cache
   599                                  
   600 00000508 48C1E910                shr       rcx, 16                                           ;Right justify the cache number
   601 0000050C B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   602 00000511 48BF-                   mov       rdi, cacheformat                                  ;"The L2 cache in this computer has size %ld kiB."
   602 00000513 [8906000000000000] 
   603 0000051B 4889CE                  mov       rsi, rcx                                          ;Copy the size of the L2 cache into the second passing parameter
   604 0000051E E8(00000000)            call      printf                                            ;Use external function to handle the output
   605                                  
   606                                  ;===== Find the processor brand id ========================================================================================================================================
   607                                  ;This module is intended for those cpus that have not implemented the Brand String method of identification.  Using the processor
   608                                  ;signature number and the brand id number one can go to tables and find the same information as Brand String.  As a useful exercise
   609                                  ;this program computes processor signature number and brand id number for your general information.  Ref: App-Note 485, p. 17.
   610                                  
   611 00000523 BB00000000              mov qword rbx, 0                                            ;Clear out previous noise in rbx.
   612 00000528 B801000000              mov qword rax, 1                                            ;1 is the input to the function cpuid
   613 0000052D 0FA2                    cpuid                                                       ;Postconditions: The Brand ID of the cpu is in rbx[7:0]
   614 0000052F B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   615 00000534 48BF-                   mov       rdi, brandidformat                                ;"The brand id number of the CPU in this computer is %ld."
   615 00000536 [A505000000000000] 
   616 0000053E 4889DE                  mov       rsi, rbx                                          ;Place a copy of the Brand ID into rsi
   617 00000541 E8(00000000)            call      printf                                            ;Use external function to handle the output
   618                                  
   619                                  ;===== Obtain and display the serial number ===============================================================================================================================
   620                                  ;Chapter6
   621                                  
   622                                  ;Test if serial number support is implemented on this machine
   623 00000546 B801000000              mov       rax, 0x0000000000000001                           ;1 is the input value
   624 0000054B 0FA2                    cpuid                                                       ;Postconditions: rdx[18:18] == 1 determines support for serial number
   625 0000054D 4881E200000400          and       rdx, 262144                                       ;Change all bits except bit #18 to zeros
   626                                  ;if rdx==0 then cpu serial number is not implemented on this computer.
   627 00000554 4883FA00                cmp       rdx, 0
   628 00000558 7520                    jne       obtainserialnumber
   629 0000055A B800000000              mov       rax, 0
   630 0000055F 48BF-                   mov       rdi, stringformat                                 ;"%s"
   630 00000561 [EE07000000000000] 
   631 00000569 48BE-                   mov       rsi, noserialnumbermessage                        ;"Extraction of serial number is not implemented in this cup."
   631 0000056B [BA06000000000000] 
   632 00000573 E8(00000000)            call      printf                                            ;Use external function to handle the output
   633 00000578 EB5C                    jmp       extractfrequencies
   634                                  
   635                                  obtainserialnumber:
   636                                  
   637 0000057A B801000000              mov       rax, 0x0000000000000001
   638 0000057F 0FA2                    cpuid                                                       ;rax holds the CPU signature, which is the first third of the serial number.
   639 00000581 4989C6                  mov       r14, rax                                          ;Copy first third of the serial number to r14 for safekeeping.
   640 00000584 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   641 00000589 48BF-                   mov       rdi, serialnumberinitial                          ;"The serial number of the CPU is %08ld"
   641 0000058B [FB06000000000000] 
   642 00000593 4C89F6                  mov       rsi, r14
   643 00000596 E8(00000000)            call      printf                                            ;Use external function to handle the output
   644                                  
   645 0000059B B803000000              mov       rax, 0x0000000000000003
   646 000005A0 0FA2                    cpuid                                                       ;rax holds the CPU signature, which is the second third of the serial number.
   647 000005A2 4989D6                  mov       r14, rdx                                          ;Copy middle third of the serial number to r14 for safekeeping
   648 000005A5 4989CF                  mov       r15, rcx                                          ;Copy last third of the serial number to r15 for safekeeping
   649                                  
   650 000005A8 B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   651 000005AD 48BF-                   mov       rdi, serialnumbermiddle                           ;"%08ld"
   651 000005AF [2107000000000000] 
   652 000005B7 4C89F6                  mov       rsi, r14                                          ;Copy the middle third of the serial number to the second passing parameter
   653 000005BA E8(00000000)            call      printf                                            ;Use external function to handle the output
   654                                  
   655 000005BF B800000000              mov qword rax, 0                                            ;A zero in rax means printf accepts no data from xmm registers
   656 000005C4 48BF-                   mov       rdi, serialnumberlast                             ;"%08ld"
   656 000005C6 [2707000000000000] 
   657 000005CE 4C89FE                  mov       rsi, r15                                          ;Copy the last third of the serial number to the second passing parameter
   658 000005D1 E8(00000000)            call      printf                                            ;Use external function to handle the output
   659                                  
   660                                  ;===== Obtain and display the CPU max and min frequencies ================================================================================================================
   661                                  
   662                                  extractfrequencies:
   663 000005D6 B816000000              mov rax,0x0000000000000016
   664 000005DB 0FA2                    cpuid
   665                                  ;The next 2 instruction are un-necessary.  The cpuid instruction will zero out the upper 48 bits of both registers.  The two instructions simply emphasize that the
   666                                  ;the max and min numbers will be in the lowest 16 bits of the two registers.
   667 000005DD 4825FFFF0000            and       rax,0x000000000000FFFF                            ;Zero out the upper 48 bits of rax and preserve the lower 16 bits
   668 000005E3 4881E3FFFF0000          and       rbx,0x000000000000FFFF                            ;Zero out the upper 48 bits of rbx and preserve the lower 16 bits
   669                                  
   670                                  ;cpuid will return zero throughout both registers rax and rbx if input value 0x16 is not implemented in the present processor.
   671                                  
   672 000005EA 4883F800                cmp rax, 0
   673 000005EE 7516                    jne       showfrequencies
   674 000005F0 B800000000              mov       rax, 0
   675 000005F5 48BF-                   mov       rdi, cpufrequencynotsupported
   675 000005F7 [9707000000000000] 
   676 000005FF E8(00000000)            call      printf
   677 00000604 EB1A                    jmp       preparetoexit
   678                                  
   679                                  showfrequencies:
   680 00000606 48BF-                   mov       rdi,cpufrequency
   680 00000608 [2E07000000000000] 
   681 00000610 4889C6                  mov       rsi, rax                                          ;Copy minimum frequency to second parameter
   682 00000613 4889DA                  mov       rdx, rbx                                          ;Copy maximum frequency to third parameter
   683 00000616 B800000000              mov qword rax,0                                             ;Do not output from any xmm registers
   684 0000061B E8(00000000)            call      printf                                            ;Call a library function to produce the output
   685                                  
   686                                  preparetoexit:                                              ;Entry point for a jump instruction
   687                                  ;==========================================================================================================================================================================
   688                                  ;===== End of the application: Identify the CPU ===========================================================================================================================
   689                                  ;==========================================================================================================================================================================
   690                                  
   691                                  
   692                                  ;==========================================================================================================================================================================
   693                                  ;===== Begin State Component Restore ======================================================================================================================================
   694                                  ;==========================================================================================================================================================================
   695                                  
   696                                  ;===== Check the flag to determine if state components were really backed up ===============================================================================================
   697                                  
   698 00000620 5B                      pop        rbx                                              ;Obtain a copy of the flag that indicates state component backup or not.
   699                                  
   700 00000621 4883FB00                cmp        rbx, 0                                           ;If there was no backup of state components then jump past the restore section.
   701 00000625 7426                    je         restoregprs                                      ;Go to restore GPRs
   702                                  
   703                                  ;Continue with restoration of state components;
   704                                  
   705                                  ;Precondition: edx:eax must hold the state component bitmap.  Therefore, go get a new copy of that bitmap.
   706                                  
   707                                  ;Preconditions for obtaining the bitmap from the cpuid instruction
   708 00000627 B80D000000              mov        rax, 0x000000000000000d                          ;Place 13 in rax.  This number is provided in the Intel manual
   709 0000062C B900000000              mov        rcx, 0                                           ;0 is parameter for subfunction 0
   710                                  
   711                                  ;Call the function
   712 00000631 0FA2                    cpuid                                                       ;cpuid is an essential function that returns information about the cpu
   713                                  
   714                                  ;Postcondition: The bitmap in now in edx:eax
   715                                  
   716                                  ;Future insurance: Make sure the bitmap is limited to a maximum of 3 state components.
   717 00000633 41BF07000000            mov        r15, 7
   718 00000639 4C21F8                  and        rax, r15
   719 0000063C 41BF00000000            mov        r15, 0
   720 00000642 4C21FA                  and        rdx, r15
   721                                  
   722 00000645 0FAE2C25[00000000]      xrstor     [backuparea]
   723                                  
   724                                  ;==========================================================================================================================================================================
   725                                  ;===== End State Component Restore ========================================================================================================================================
   726                                  ;==========================================================================================================================================================================
   727                                  
   728                                  
   729                                  ;=========== Restore GPR values and return to the caller ==================================================================================================================
   730                                  
   731                                  restoregprs:
   732                                  
   733 0000064D 9D                      popf                                                        ;Restore rflags
   734 0000064E 415F                    pop        r15                                              ;Restore r15
   735 00000650 415E                    pop        r14                                              ;Restore r14
   736 00000652 415D                    pop        r13                                              ;Restore r13
   737 00000654 415C                    pop        r12                                              ;Restore r12
   738 00000656 415B                    pop        r11                                              ;Restore r11
   739 00000658 415A                    pop        r10                                              ;Restore r10
   740 0000065A 4159                    pop        r9                                               ;Restore r9
   741 0000065C 4158                    pop        r8                                               ;Restore r8
   742 0000065E 5F                      pop        rdi                                              ;Restore rdi
   743 0000065F 5E                      pop        rsi                                              ;Restore rsi
   744 00000660 5A                      pop        rdx                                              ;Restore rdx
   745 00000661 59                      pop        rcx                                              ;Restore rcx
   746 00000662 5B                      pop        rbx                                              ;Restore rbx
   747 00000663 5D                      pop        rbp                                              ;Restore rbp
   748                                  
   749                                  
   750                                  ;===== Send a return value to the caller ===================================================================================================================================
   751                                  ;No special value is required for this program, therefore, we'll simply send negative one to the caller program.
   752                                  
   753 00000664 48C7C0FFFFFFFF          mov        rax, -1
   754                                  
   755 0000066B C3                      ret;                                                        ;ret pops the stack (removes 8 bytes) and resumes execution at the address that was popped.
   756                                  
   757                                  ;===== End of function processoridentification ============================================================================================================================
   758                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
